---
title: run time testing with assertive
author: Randy
---

# Assertive

```{r error = TRUE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
counts <- c(1, 2.2, 3, 4.5)
stopifnot(
  # check the variable is numeric
  is.numeric(counts),
  # check all values are non-negative
all(counts >= 0),
# check all values are whole numbers isTRUE(all.equal(counts, round(counts)))
)
```


```{r}
suppressPackageStartupMessages(library(assertive, quietly = TRUE))
suppressPackageStartupMessages(library(magrittr, quietly = TRUE))

library(assertive)
assert_is_numeric(counts)
assert_all_are_non_negative(counts)
assert_all_are_whole_numbers(counts)
```


Improve the `assertive()` with pipeline

```{r}
counts %>%
  assert_is_numeric() %>%
  assert_all_are_non_negative() %>%
  assert_all_are_whole_numbers()

counts %>% assert_any_are_na()
```

```{r}
attributes(is_numeric(letters))

is_non_negative(c(10, 1, 0, -1, -10, NA))
is_numeric(c(10, 1, 0, -1, -10, NA))

attributes(is_non_negative(c(10, 1, 0, -1, -10, NA)))
assert_all_are_non_negative(c(10, 1, 0, -1, -10, NA))
assert_any_are_non_negative(c(10, 1, 0, -1, -10, NA))
```

```{r}
list <- ls("package:assertive", pattern = "finite")
list
apropos("finite")

```

This design helps distinguish be- tween interactive and programmatic use.

- assertive.base, 
- assertive.properties, 
- assertive.types, 
- assertive.numbers.

```{r}
library(assertive)

x <- c(TRUE, FALSE, NA)
assert_all_are_true(x)
assert_any_are_true(x)
assert_all_are_na(x)
assert_any_are_na(x)

identical(x, TRUE)
is_identical_to_na(x)
```


```{r}
(y <- c(a = TRUE))
isTRUE(y)
is_identical_to_true(y)
is_identical_to_true(y, allow_attributes = TRUE)
is_identical_to_na(matrix())
## [1] FALSE
## Cause of failure:  matrix() is not identical to NA; 
## its value is structure(NA, dim = c(1L, 1L)). 
is_identical_to_na(matrix(), allow_attributes = TRUE)
```


# assertive.properties

```{r}
x <- 1:5
has_names(x)
names(x) <- character(5)
has_names(x)
names(x) <- month.abb[1:5]
has_names(x)
```

Similarly, `has_rownames()`, `has_colnames()`, and `has_dimnames()` check for those particular kinds of names specific to data.frames, matrices, and arrays.

```{r}
has_rownames(stack.x)
has_colnames(stack.x)
has_dimnames(stack.x)
```

```{r}
l <- list(a = 1:5)
is_scalar(l, metric = "elements")
is_of_length(l, 1)
are_same_length(x, y)
have_same_dims(y, l)
```

All functions have length one, and hence are scalar with the default metric. The number of elements is usually more than one though.

You can also check for the presence of arbitrary attributes using `has_attributes()`, which is vectorized over its second argument. `has_no_attributes()` and `has_any_attributes()` check for the presence or absence of any attributes at all.

```{r}
attributes(data.frame())
has_attributes(data.frame(), c("names", "class", "dim"))
has_no_attributes(stack.x)
has_any_attributes(1:5)
```

```{r}
(x <- c(1, 1, 1, 2, 2, 2, 3, 3, 3))
has_no_duplicates(x)
has_duplicates(x)

is_atomic(x)
is_recursive(x)
is_vector(x)
is_unsorted(x)
is_unsorted(y)
```


```{r}
## Checks to see if the input is 
## a QR decomposition of a matrix.
?is_qr
## Checks to see if the input is relistable.
?is_relistable

assert_is_relistable(as.relistable(list(1,2,3)))
assert_is_relistable(list(1,2,3))

is_a_string(LETTERS)
```


```{r}
x <- c(-0.1, 0, 0.5, 1, 1.1) 
is_proportion(x)
is_proportion(x, 
              lower_is_strict = TRUE,
              upper_is_strict = TRUE)

is_percentage(x)
eps <- 50 * .Machine$double.eps
eps
x <- 123.456 + c(-10 * eps, -eps, 0, eps, 10 * eps)
is_equal_to(x, 123.456)
is_equal_to(x, 123.456, tol = 0)

is_real(x)
```

# assertive.files

```{r}
r_executable <- file.path(R.home("bin"), "R")
## "R.exe" under Windows
is_existing_file(r_executable)
is_dir(r_executable)
is_readable_connection(r_executable)
is_readable_file(r_executable)
is_writable_file(r_executable)
is_executable_file(r_executable)

assert_any_are_true(c(is_a_string(x),
                      is_file_connection(x) &&
                        is_readable_connection(x)))
```

```{r}
contents_of_base_pkg_dir <- 
  dir(system.file(package = "base"),
      full.names = TRUE)
```


# assertive.strings

```{r}
x <- c("a", "", NA)
is_non_empty_character(x)
is_empty_character(x)
is_non_missing_nor_empty_character(x)
is_missing_or_empty_character(x)
```

# assertive.matrices

```{r}
(m <- matrix(c(1, eps, 0, 1), nrow = 2))
is_identity_matrix(m)
is_identity_matrix(m, tol = 0)
is_diagonal_matrix(m)
is_symmetric_matrix(m)
is_upper_triangular_matrix(m)
is_zero_matrix(m)
```

# assertive.set

```{r}
x <- c(1, 3, 5, 4, 2)
y <- c(6, 1, 4, 2, 3, 5)
is_subset(x, y)
is_superset(y, x)
are_set_equal(x, y)
```

# assertive.models

```{r}
model <- lm(weight ~ feed, chickwts) 
has_terms(chickwts)
has_terms(model)

an_empty_model <- lm(weight ~ 0, ChickWeight)
is_empty_model(an_empty_model)

a_model_with_factors <- lm(uptake ~ conc * Type, CO2)
is_empty_model(a_model_with_factors)

```


# assertive.reflection


assertive.reflection lets you check the state of your system: how you are run- ning R, what OS and IDE you are running, and so on.

```{r}
is_r_devel()
is_r_alpha()
is_r_release()
is_r_release_candidate()
is_r_revised()
is_r_patched()
is_interactive()
is_batch_mode()
is_r_slave()

is_windows_10()
is_osx()
is_bsd()
is_rstudio()
is_revo_r()
is_rstudio_server()
```

# assertive.datetimes


```{r}
is_date_string(c("21JUL1954", "wednesday"), "%d%b%Y")
```




```{r}
assert_all_are_nan(-1:1 / 0, severity = "warning")
assert_all_are_nan(-1:1 / 0, severity = "none")
```

# Fail Early, Fail Often

***Make each module fail fast – either it does the right thing or it stops.***

More recently, this idea has been updated in the phrase “fail early, fail often.” The “fail often” part means that you need lots of checks to ensure the integrity of your code. This is especially true of R code: the flexibility of the language gives you a lot of scope for things going wrong.

```{r}
geomean2 <- function(x, na.rm = FALSE) {
  assert_is_numeric(x)
  exp(mean(log(x), na.rm = na.rm))
}

geomean2("a")

geomean2(c(2, 4, 6))

geomean2(rnorm(20))

geomean3 <- function(x, na.rm = FALSE) {
  assert_is_numeric(x)
  # Don't worry about NAs here
  if (any(is_negative(x), na.rm = TRUE)) {
    warning(
      "x contains negative values, ",
      "so the geometric mean makes no sense."
    )
    return(NaN)
  }
  exp(mean(log(x), na.rm = na.rm))
}

geomean3(rnorm(20))

x <- rlnorm(20)
x[sample(20, 5)] <- NA
geomean3(x, na.rm = c(1.5, 0))

```



```{r}
geomean4 <- function(x, na.rm = FALSE) {
  assert_is_numeric(x)
  if (any(is_negative(x), na.rm = TRUE)) {
    warning(
      "x contains negative values,",
      "so the geometric mean makes no sense."
    )
    return(NaN)
  }
  na.rm <- coerce_to(use_first(na.rm), "logical")
  exp(mean(log(x), na.rm = na.rm))
}
geomean4(x, na.rm = 1.5)
```



















